// SPDX-License-Identifier: LGPL-3.0-only
/*
* Author: Hao-Xin Wang <wanghx18@mails.tsinghua.edu.cn>
* Creation Date: 2021-08-20
*
* Description: QuantumLiquids/MPS project. SVD performance test on single processor
*/

/**
 * @note this file only compile/link in cmakes, won't add to tests; users should run it by self
 * @note only support U1U1 quantum number and double
 */


#include "../tests/testing_utils.h"
#include "gqten/gqten.h"
#include "gqten/utility/timer.h"

#include "gtest/gtest.h"

#include <vector>
#include <iostream>
#include <fstream>
#include <thread>

#ifdef Release
#define NDEBUG
#endif

#include <assert.h>

#include "mkl.h"

using namespace gqten;

using std::vector;
using std::cout;
using std::endl;
using std::string;

using U1U1QN = QN<U1QNVal, U1QNVal>;
using IndexT = Index<U1U1QN>;
using QNSctT = QNSector<U1U1QN>;
using QNSctVecT = QNSectorVec<U1U1QN>;

using DQLTensor = QLTensor<QLTEN_Double, U1U1QN>;
using ZQLTensor = QLTensor<QLTEN_Complex, U1U1QN>;

const std::vector<size_t> default_thread_nums = {10, 20, 40, 80};
const std::vector<size_t> default_outer_thread_nums = {1, 2};
//forward declaration
int Parser(int argc, char *argv[],
           std::string &path,
           vector<size_t> &,
           vector<size_t> &);

/**
 * 
 * 
 * @param argv    --path=[the working directory], e.g. --path=./tensor_package; if no this arguement, --path=./ by default.
 * @param argv    --total_thread_nums=[a list of number of threads], e.g. --total_thread_nums=12,24,48,96 note no space between this arguement.
 *                 by default, --total_thread_nums=10,20,40,80.
 * @param argv    --outer_thread_nums=[a list of number of threads], e.g. --outer_thread_nums=1,2,3. by default, --outer_thread_nums=1,2.
 * 
 * @note test cases are generated by total_thread_nums \cross outer_thread_nums
 */
int main(int argc, char *argv[]) {

  std::string working_path;
  std::vector<size_t> total_thread_nums, outer_thread_nums;
  Parser(argc, argv, working_path, total_thread_nums, outer_thread_nums);
  cout << "total thread number list: [ ";
  for (size_t i = 0; i < total_thread_nums.size(); i++) {
    cout << total_thread_nums[i];
    if (i < total_thread_nums.size() - 1) {
      cout << ", ";
    } else {
      cout << "]\n";
    }
  }
  cout << "outer thread number list: [ ";
  for (size_t i = 0; i < outer_thread_nums.size(); i++) {
    cout << outer_thread_nums[i];
    if (i < outer_thread_nums.size() - 1) {
      cout << ", ";
    } else {
      cout << "]\n";
    }
  }


  //Loading file
  DQLTensor state;
  std::string file = "state.gqten";

  if (access(file.c_str(), 4) != 0) {
    std::cout << "The progress doesn't access to read the file " << file << "!" << std::endl;
    exit(1);
  }
  std::ifstream ifs(file, std::ios::binary);
  if (!ifs.good()) {
    std::cout << "The progress can not read the file " << file << " correctly!" << std::endl;
    exit(1);
  }
  ifs >> state;

  std::cout << "The progress has loaded the tensors." << std::endl;
  cout << "Concise Info of tensors: \n";
  cout << "state.gqten:";
  state.ConciseShow();


// ???
// #ifndef QLTEN_TIMING_MODE
// #define QLTEN_TIMING_MODE
// #endif

  const size_t svd_ldims = 2;
  const U1U1QN left_div = Div(state);
  const QLTEN_Double trunc_err = 1e-8;
  const size_t Dmin = state.GetIndexes()[0].dim();
  const size_t Dmax = Dmin;

  const size_t max_threads = std::thread::hardware_concurrency();
  for (size_t i = 0; i < total_thread_nums.size(); i++) {
    cout << "[test case " << i << " ]\n";
    size_t total_thread_num = total_thread_nums[i];
    if (total_thread_nums[i] > max_threads) {
      std::cout << "warning: maximal thread are " << max_threads << ", but require thread " << total_thread_nums[i]
                << "." << std::endl;
      std::cout << "test case passed." << std::endl;
      continue;
    }
    hp_numeric::SetTensorManipulationTotalThreads(total_thread_nums[i]);
    for (size_t j = 0; j < outer_thread_nums.size(); j++) {
      DQLTensor u, s, vt;
      QLTEN_Double actual_trunc_err;
      size_t D;
      Timer single_process_svd_timer("single processor SVD (total thread "
                                         + std::to_string(total_thread_nums[i])
                                         + ", outer thread "
                                         + std::to_string(outer_thread_nums[j])
                                         + ")"
      );
      SVD(&state,
          svd_ldims, left_div,
          trunc_err, Dmin, Dmax,
          &u, &s, &vt, &actual_trunc_err, &D
      );
      single_process_svd_timer.PrintElapsed();

      u = std::move(DQLTensor());
      s = u;
      vt = u;
      single_process_svd_timer.ClearAndRestart();
      SVD(&state,
          svd_ldims, left_div,
          trunc_err, Dmin, Dmax,
          &u, &s, &vt, &actual_trunc_err, &D
      );
      single_process_svd_timer.PrintElapsed();
    }

  }
  return 0;
}

int Parser(int argc, char *argv[],
           std::string &path,
           vector<size_t> &total_thread_nums,
           vector<size_t> &outer_thread_nums) {
  int nOptionIndex = 1;
  string thread_nums_string;
  string outer_thread_string;

  string arguement1 = "--path=";
  string arguement2 = "--total_thread_nums=";
  string arguement3 = "--outer_thread_nums=";
  while (nOptionIndex < argc) {
    if (strncmp(argv[nOptionIndex], arguement1.c_str(), arguement1.size()) == 0) {
      path = &argv[nOptionIndex][arguement1.size()];  // path
    } else if (strncmp(argv[nOptionIndex], arguement2.c_str(), arguement2.size()) == 0) {
      thread_nums_string = &argv[nOptionIndex][arguement2.size()];// thread number list
    } else if (strncmp(argv[nOptionIndex], arguement3.c_str(), arguement3.size()) == 0) {
      outer_thread_string = &argv[nOptionIndex][arguement3.size()];
    } else {
      cout << "Options '" << argv[nOptionIndex] << "' not valid. Run '" << argv[0] << "' for details." << endl;
      //   return -1;
    }
    nOptionIndex++;
  }

//split thread num list
  const char *split = ",";
  char *p;
  const size_t MAX_CHAR_LENTH = 1000;
  char thread_nums_char[MAX_CHAR_LENTH];
  for (size_t i = 0; i < MAX_CHAR_LENTH; i++) {
    thread_nums_char[i] = 0;
  }

  strcpy(thread_nums_char, thread_nums_string.c_str());

  p = strtok(thread_nums_char, split);
  while (p != nullptr) {
    total_thread_nums.push_back(atoi(p));
    p = strtok(nullptr, split);
  }

  if (total_thread_nums.size() == 0) {
    total_thread_nums = default_thread_nums; //default thread numbers
  }

//split inner thread num list
  for (size_t i = 0; i < MAX_CHAR_LENTH; i++) {
    thread_nums_char[i] = 0;
  }
  strcpy(thread_nums_char, outer_thread_string.c_str());
  p = strtok(thread_nums_char, split);
  while (p != nullptr) {
    outer_thread_nums.push_back(atoi(p));
    p = strtok(nullptr, split);
  }

  if (outer_thread_nums.size() == 0) {
    outer_thread_nums = default_outer_thread_nums; //default thread numbers
  }

//path setting
  if (path.size() == 0) {
    path = "./";
  }

  return 0;

}
