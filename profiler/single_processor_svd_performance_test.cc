// SPDX-License-Identifier: LGPL-3.0-only
/*
* Author: Hao-Xin Wang <wanghx18@mails.tsinghua.edu.cn>
* Creation Date: 2021-08-20
*
* Description: GraceQ/mps2 project. SVD performance test on single processor
*/

/**
 * @note this file only compile/link in cmakes, won't add to tests; users should run it by self
 * @note only support U1U1 quantum number and double
 */


#include "../tests/testing_utils.h"
#include "gqten/gqten.h"
#include "gqten/utility/timer.h"

#include "gtest/gtest.h"

#include <vector>
#include <iostream>
#include <fstream>
#include <thread>


#ifdef Release
  #define NDEBUG
#endif

#include <assert.h>

#include "mkl.h"


using namespace gqten;

using std::vector;
using std::cout;
using std::endl;
using std::string;

using U1U1QN = QN<U1QNVal, U1QNVal>;
using IndexT = Index<U1U1QN>;
using QNSctT = QNSector<U1U1QN>;
using QNSctVecT = QNSectorVec<U1U1QN>;

using DGQTensor = GQTensor<GQTEN_Double, U1U1QN>;
using ZGQTensor = GQTensor<GQTEN_Complex, U1U1QN>;


const std::vector<size_t> default_thread_nums =  {10, 20, 40,80};
const std::vector<size_t> default_outer_thread_nums = {1,2};
//forward declaration
int Parser(int argc, char *argv[],
            std::string& path,
            vector<size_t>&,
            vector<size_t>&);


/**
 * 
 * 
 * @param argv    --path=[the working directory], e.g. --path=./tensor_package; if no this arguement, --path=./ by default.
 * @param argv    --total_thread_nums=[a list of number of threads], e.g. --total_thread_nums=12,24,48,96 note no space between this arguement.
 *                 by default, --total_thread_nums=10,20,40,80.
 * @param argv    --outer_thread_nums=[a list of number of threads], e.g. --outer_thread_nums=1,2,3. by default, --outer_thread_nums=1,2.
 * 
 * @note test cases are generated by total_thread_nums \cross outer_thread_nums
 */
int main(int argc, char *argv[]){

  
  std::string working_path;
  std::vector<size_t> total_thread_nums, outer_thread_nums;
  Parser(argc, argv, working_path, total_thread_nums,outer_thread_nums);
  cout << "total thread number list: [ ";
  for(size_t i=0;i < total_thread_nums.size(); i++){
    cout << total_thread_nums[i];
    if(i<total_thread_nums.size()-1){
      cout << ", ";
    }else{
      cout << "]\n";
    }
  }
  cout << "outer thread number list: [ ";
  for(size_t i=0;i < outer_thread_nums.size(); i++){
    cout << outer_thread_nums[i];
    if(i<outer_thread_nums.size()-1){
      cout << ", ";
    }else{
      cout << "]\n";
    }
  }

  
  //Loading file
  DGQTensor state;
  std::string file = "state.gqten";

  if( access( file.c_str(), 4) != 0){
    std::cout << "The progress doesn't access to read the file " << file << "!" << std::endl;
    exit(1);
  }
  std::ifstream ifs(file, std::ios::binary);
  if(!ifs.good()){
    std::cout << "The progress can not read the file " << file << " correctly!" << std::endl;
    exit(1);
  }
  ifs >> state;

  std::cout << "The progress has loaded the tensors." <<std::endl;
  cout << "Concise Info of tensors: \n";
  cout << "state.gqten:"; state.ConciseShow();


// ???
// #ifndef GQTEN_TIMING_MODE
// #define GQTEN_TIMING_MODE
// #endif

  const size_t svd_ldims = 2;
  const U1U1QN left_div = Div(state);
  const GQTEN_Double trunc_err = 1e-8;
  const size_t Dmin = state.GetIndexes()[0].dim();
  const size_t Dmax = Dmin;

  const size_t max_threads = std::thread::hardware_concurrency();
  for(size_t i=0;i<total_thread_nums.size();i++){
    cout << "[test case " << i << " ]\n";
    size_t total_thread_num = total_thread_nums[i];
    if(total_thread_nums[i] > max_threads  ){
      std::cout << "warning: maximal thread are " << max_threads <<", but require thread " << total_thread_nums[i] <<"." << std::endl;
      std::cout << "test case passed." <<std::endl;
      continue;
    }
    hp_numeric::SetTensorManipulationTotalThreads(total_thread_nums[i]);
    hp_numeric::SetTensorTransposeNumThreads(total_thread_nums[i]);
    for(size_t j=0;j<outer_thread_nums.size();j++){
      hp_numeric::SetTensorDecompOuterParallelThreads(outer_thread_nums[j]);

      DGQTensor u,s,vt;
      GQTEN_Double actual_trunc_err;
      size_t D;
      Timer single_process_svd_timer("single processor SVD (total thread " 
                                   + std::to_string(total_thread_nums[i]) 
                                   + ", outer thread "
                                   + std::to_string(outer_thread_nums[j])
                                   + ")"
                                   );
      SVD(&state,
          svd_ldims, left_div,
          trunc_err, Dmin, Dmax,
          &u, &s, &vt, &actual_trunc_err, &D
         );
      single_process_svd_timer.PrintElapsed();

      u = std::move(DGQTensor());
      s = u; vt = u;
      single_process_svd_timer.ClearAndRestart();
      SVD(&state,
          svd_ldims, left_div,
          trunc_err, Dmin, Dmax,
          &u, &s, &vt, &actual_trunc_err, &D
         );
      single_process_svd_timer.PrintElapsed();
    }

  }
  return 0;
}

int Parser(int argc, char *argv[],
            std::string& path,
            vector<size_t>& total_thread_nums,
            vector<size_t>& outer_thread_nums){
int nOptionIndex = 1;
string thread_nums_string;
string outer_thread_string;
 
string arguement1 = "--path=";
string arguement2 = "--total_thread_nums=";
string arguement3 = "--outer_thread_nums=";
while (nOptionIndex < argc){
  if (strncmp(argv[nOptionIndex], arguement1.c_str() , arguement1.size()) == 0){
    path = &argv[nOptionIndex][arguement1.size()];  // path
  }else if (strncmp(argv[nOptionIndex], arguement2.c_str(), arguement2.size()) == 0){
    thread_nums_string = &argv[nOptionIndex][arguement2.size()];// thread number list
  }else if (strncmp(argv[nOptionIndex], arguement3.c_str(), arguement3.size()) == 0){
    outer_thread_string = &argv[nOptionIndex][arguement3.size()];
  }else{
    cout << "Options '" << argv[nOptionIndex] << "' not valid. Run '" << argv[0] << "' for details." << endl;
  //   return -1;
  }
  nOptionIndex++;
}

//split thread num list
const char* split = ",";
char *p;
const size_t MAX_CHAR_LENTH = 1000;
char thread_nums_char[MAX_CHAR_LENTH];
for(size_t i =0;i< MAX_CHAR_LENTH;i++){
  thread_nums_char[i] = 0;
}

strcpy(thread_nums_char, thread_nums_string.c_str() );

p = strtok(thread_nums_char, split);
while(p != nullptr){
  total_thread_nums.push_back( atoi(p) );
  p = strtok(nullptr, split);
}

if(total_thread_nums.size() == 0){
  total_thread_nums = default_thread_nums; //default thread numbers
}

//split inner thread num list
for(size_t i =0;i< MAX_CHAR_LENTH;i++){
  thread_nums_char[i] = 0;
}
strcpy(thread_nums_char, outer_thread_string.c_str() );
p = strtok(thread_nums_char, split);
while(p != nullptr){
  outer_thread_nums.push_back( atoi(p) );
  p = strtok(nullptr, split);
}

if(outer_thread_nums.size() == 0){
  outer_thread_nums = default_outer_thread_nums; //default thread numbers
}

//path setting
if(path.size() == 0){
  path = "./";
}
 
return 0;

}
